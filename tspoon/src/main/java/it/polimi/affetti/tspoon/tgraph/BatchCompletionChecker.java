package it.polimi.affetti.tspoon.tgraph;

import org.apache.flink.api.java.tuple.Tuple2;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.stream.IntStream;

/**
 * Created by affo on 20/11/17.
 * <p>
 * Checks for the completeness of the set of batchIDs generated by one root record.
 * The length of the batchIDs ingested must be fixed and imposed by the number of steps of the topology.
 */
public class BatchCompletionChecker {
    private final Map<Long, Tree> trees = new HashMap<>();

    public boolean checkCompleteness(BatchID someBatchID) {
        return checkCompleteness(null, someBatchID);
    }

    /**
     * @param someBatchID must be at least 1 step
     * @return
     */
    public boolean checkCompleteness(Long index, BatchID someBatchID) {
        // turn to shifted representation
        someBatchID = someBatchID.getShiftedRepresentation();

        Tuple2<Integer, Integer> firsElement = someBatchID.iterator().next();
        if (index == null) {
            index = Long.valueOf(firsElement.f0);
        }
        int firstFanout = firsElement.f1;
        Tree tree = trees.computeIfAbsent(index, (key) -> new Tree(firstFanout));

        tree.ackNode(someBatchID);

        return tree.isComplete();
    }

    public boolean getCompleteness(Long index) {
        return trees.get(index).isComplete();
    }

    public void freeIndex(long index) {
        trees.remove(index);
    }

    private class Tree {
        private Tree[] children;
        private boolean[] childrenCompleteness;

        Tree(int fanout) {
            children = new Tree[fanout];
            childrenCompleteness = new boolean[fanout];
        }

        /**
         * ACKs the child in the specified batch (position, fanout).
         * Apply starting from the root.
         */
        public void ackNode(BatchID batchID) {
            Iterator<Tuple2<Integer, Integer>> iterator = batchID.iterator();
            iterator.next(); // discard the first one
            if (iterator.hasNext()) {
                ackNodeRecursive(iterator);
            }
        }

        private boolean ackNodeRecursive(Iterator<Tuple2<Integer, Integer>> iterator) {
            Tuple2<Integer, Integer> next = iterator.next();
            int position = (next.f0 - 1);

            if (!iterator.hasNext()) {
                // a leaf is always complete, no need to process
                childrenCompleteness[position] = true;
                return isComplete();
            }

            Tree child = children[position];
            if (child == null) {
                long fanout = next.f1;
                child = new Tree((int) fanout);
                children[position] = child;
            }

            boolean childCompleteness = child.ackNodeRecursive(iterator);
            childrenCompleteness[position] = childCompleteness;


            return isComplete();
        }


        boolean isComplete() {
            // if array is empty this is true
            return IntStream.range(0, childrenCompleteness.length)
                    .mapToObj(i -> childrenCompleteness[i])
                    .allMatch(el -> el);
        }
    }
}
